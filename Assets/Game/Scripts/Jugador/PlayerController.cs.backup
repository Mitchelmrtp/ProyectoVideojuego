using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.Events;
using UnityEngine.SceneManagement;
using TMPro;

public class PlayerController : MonoBehaviour
{
    public class PlayerController : MonoBehaviour
{
    // PROTECCI√ìN GLOBAL: Variable est√°tica para prevenir m√∫ltiples muertes
    private static bool globalDeathInProgress = false;
    
    [Header("Detector de suelo")]
    public float speed = 5f;
    public float jumpForce = 10f;
    public float collisionOffset = 0.05f;

    [Header("UI")]
    [SerializeField] private TextMeshProUGUI txtGravedad; // Texto que mostrar√° los cambios

    [Header("Par√°metros para detector de piso")]
    [SerializeField] private Transform detector;
    [SerializeField] private float sizeDetector = 0.2f;
    [SerializeField] private LayerMask groundLayer;

    [Header("L√≠mite de cambios de gravedad")]
    [SerializeField] private int maxGravityChanges = 2; // N√∫mero m√°ximo de veces que se puede cambiar la gravedad
    private int baseMaxGravityChanges;              
    private int gravityChangesAvailable;

    [Header("Combate")]
    public Transform controladorGolpe;
    public float radioGolpe;
    public float da√±oGolpe;
    public float tiempoEntreAtaques = 0.4f;
    public float tiempoSiguienteAtaque;
    public SwordAttack swordAttackComponent; // Referencia al componente SwordAttack

    [Header("Vida")]
    public int maxHealth = 5;
    public int currentHealth { get; private set; } // Hacer currentHealth p√∫blico pero solo lectura
    public UnityEvent<int> cambioVida; // Evento para notificar cambios en la vida
    
    [Header("Configuraci√≥n Extra")]
    public int ScenaActual;
    public bool TieneLlave = false;

    [Header("Timing")]
    [Tooltip("Duraci√≥n por defecto de la animaci√≥n de muerte (segundos).")]
    public float deathDuration = 2.2f;
    [Tooltip("Duraci√≥n por defecto del hit (segundos).")]
    public float hitDuration = 0.5f;
    
    [Header("Respawn")]
    [Tooltip("Si est√° activado, al morir el jugador se limpiar√° la lista de enemigos derrotados para que reaparezcan.")]
    public bool respawnEnemiesOnPlayerDeath = true;

    // Componentes principales
    private Rigidbody2D rb;
    private Animator animator;
    private SpriteRenderer spriteRenderer;
    
    // Input
    public ContactFilter2D movementFilter;
    Vector2 movementInput;
    List<RaycastHit2D> castCollisions = new List<RaycastHit2D>();
    private InputAction jumpAction;
    private InputAction testGravityAction;
    private InputAction moveAction;
    private InputAction attackAction;
    
    // Estados
    bool canMove = true;
    [HideInInspector] public bool isAttacking = false;
    public bool isDying { get; private set; } = false; // Hacer isDying p√∫blico pero solo lectura
    private bool isGravedadInvertida = false;
    private bool isGrounded = false;
    
    // Corrutinas
    private Coroutine deathCoroutine = null;
    private Coroutine hitCoroutine = null;
    private float horizontal;

    void Start()
    {
        // Inicializar componentes
        rb = GetComponent<Rigidbody2D>();
        animator = GetComponent<Animator>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // Inicializar input
        jumpAction = InputSystem.actions.FindAction("Jump");
        testGravityAction = new InputAction("TestGravity", InputActionType.Button, "<Mouse>/rightButton");
        testGravityAction.Enable();
        
        // Crear acciones de input para el nuevo sistema
        moveAction = new InputAction("Move", InputActionType.Value, "<Keyboard>/a,<Keyboard>/d,<Keyboard>/leftArrow,<Keyboard>/rightArrow");
        moveAction.Enable();
        
        attackAction = new InputAction("Attack", InputActionType.Button, "<Mouse>/leftButton");
        attackAction.Enable();

        // Inicializar gravedad
        baseMaxGravityChanges = maxGravityChanges;
        gravityChangesAvailable = maxGravityChanges;
        ActualizarTextoGravedad();

        // Inicializar vida
        currentHealth = maxHealth;
        cambioVida.Invoke(currentHealth);

        Debug.Log($"PlayerController iniciado. Vida: {currentHealth}/{maxHealth}, Cambios de gravedad: {gravityChangesAvailable}/{maxGravityChanges}");
        
        // Verificar par√°metros del animador
        VerificarAnimatorParametros();
        
        // Verificar SwordAttack component
        if (swordAttackComponent == null)
        {
            // Intentar encontrar SwordAttack en el mismo GameObject o en hijos
            swordAttackComponent = GetComponent<SwordAttack>();
            if (swordAttackComponent == null)
                swordAttackComponent = GetComponentInChildren<SwordAttack>();
            
            if (swordAttackComponent != null)
                Debug.Log("‚úÖ SwordAttack component encontrado autom√°ticamente");
            else
                Debug.LogWarning("‚ö†Ô∏è SwordAttack component no encontrado. As√≠gnalo manualmente en el inspector para activar el swordHitBox");
        }
        else
        {
            Debug.Log("‚úÖ SwordAttack component asignado correctamente");
        }
        
        // CR√çTICO: Verificar y desactivar DarkMovement si existe (evita doble sistema)
        MonoBehaviour darkMovement = GetComponent("DarkMovement") as MonoBehaviour;
        if (darkMovement != null)
        {
            darkMovement.enabled = false;
            Debug.LogWarning("‚ö†Ô∏è DarkMovement detectado y DESACTIVADO para evitar conflictos con PlayerController");
        }
        
        // Verificar otros componentes que puedan interferir
        MonoBehaviour[] allComponents = GetComponents<MonoBehaviour>();
        foreach (MonoBehaviour component in allComponents)
        {
            if (component != this && component.GetType().Name.Contains("Movement"))
            {
                Debug.LogWarning($"‚ö†Ô∏è Componente de movimiento detectado: {component.GetType().Name}");
            }
        }
    }

    void Update()
    {
        if (detector != null)
        {
            Collider2D colision = Physics2D.OverlapCircle(detector.position, sizeDetector, groundLayer);
            isGrounded = colision != null;
            
            // Para el sistema de gravedad invertida, ajustar la l√≥gica de salto
            bool canJump = isGravedadInvertida ? !isGrounded : isGrounded;

            if (jumpAction != null && jumpAction.WasPressedThisFrame() && canJump && canMove)
            {
                Debug.Log("El personaje debe saltar...");
                float jumpDirection = isGravedadInvertida ? -jumpForce : jumpForce;
                rb.linearVelocity = new Vector2(rb.linearVelocity.x, jumpDirection);
            }

            // Actualizar par√°metros del animator relacionados con salto/grounded
            if (animator != null)
            {
                if (HasAnimatorParameter("isJumping", AnimatorControllerParameterType.Bool))
                    animator.SetBool("isJumping", !isGrounded && rb.linearVelocity.y > 0f);
                if (HasAnimatorParameter("isFalling", AnimatorControllerParameterType.Bool))
                    animator.SetBool("isFalling", !isGrounded && rb.linearVelocity.y < 0f);
                if (HasAnimatorParameter("isGrounded", AnimatorControllerParameterType.Bool))
                    animator.SetBool("isGrounded", isGrounded);
                if (HasAnimatorParameter("verticalVel", AnimatorControllerParameterType.Float))
                    animator.SetFloat("verticalVel", rb.linearVelocity.y);
            }
        }

        // Control de gravedad manual
        if (testGravityAction.WasPressedThisFrame())
        {
            if (gravityChangesAvailable > 0)
            {
                CambiarGravedad();
                gravityChangesAvailable--;
                Debug.Log($"Cambio de gravedad realizado. Restantes: {gravityChangesAvailable}/{maxGravityChanges}");
                ActualizarTextoGravedad();
            }
            else
            {
                Debug.Log("‚ùå No tienes m√°s cambios de gravedad disponibles.");
            }
        }
        
        // Debug: Mostrar estado de muerte en tiempo real
        if (isDying && Time.frameCount % 60 == 0) // Cada segundo aproximadamente
        {
            Debug.Log($"üîç Estado de muerte: isDying={isDying}, deathCoroutine={deathCoroutine != null}, currentHealth={currentHealth}");
        }
        
        // Fallback de emergencia: si el jugador lleva mucho tiempo muerto sin respawnear
        if (currentHealth <= 0 && !isDying && deathCoroutine == null)
        {
            Debug.LogWarning("‚ö†Ô∏è Jugador muerto sin proceso de respawn activo. Forzando respawn...");
            PlayerDeath();
        }
    }

    void OnMove(InputValue movementValue)
    {
        Vector2 fullInput = movementValue.Get<Vector2>();
        movementInput = new Vector2(fullInput.x, 0);
        Debug.Log($"Input recibido: {fullInput.x}, movementInput: {movementInput.x}");
    }

    void OnFire()
    {
        // Evitar atacar si el jugador est√° muerto o muriendo
        if (currentHealth <= 0 || isDying || deathCoroutine != null)
        {
            Debug.Log("OnFire: jugador est√° muerto o muriendo, ignorando ataque");
            return;
        }
        
        // Evitar iniciar otro ataque mientras ya se est√° atacando
        if (isAttacking)
        {
            Debug.Log("OnFire: ya se est√° atacando, ignorando input.");
            return;
        }
        
        // Evitar atacar si no se puede mover
        if (!canMove)
        {
            Debug.Log("OnFire: movimiento bloqueado, ignorando ataque");
            return;
        }

        if (animator == null)
        {
            Debug.LogError("OnFire: animator es null");
            return;
        }

        if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Trigger))
            animator.SetTrigger("isAttacking");
        else if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Bool))
            animator.SetBool("isAttacking", true);

        Debug.Log("Attacked");

        // Llamamos directamente al m√©todo de ataque
        SwordAttack();
    }

    void FixedUpdate()
    {
        if (canMove)
        {
            float horizontalInput = movementInput.x;
            
            // Aplicar movimiento
            rb.linearVelocity = new Vector2(horizontalInput * speed, rb.linearVelocity.y);
            
            // Configurar animaci√≥n de correr/caminar (basado en PlayerController2)
            if (animator != null)
            {
                // Intentar primero con "running"
                if (HasAnimatorParameter("running", AnimatorControllerParameterType.Bool))
                {
                    animator.SetBool("running", horizontalInput != 0.0f);
                }
                // Si no existe "running", intentar con "isMoving"
                else if (HasAnimatorParameter("isMoving", AnimatorControllerParameterType.Bool))
                {
                    animator.SetBool("isMoving", horizontalInput != 0.0f);
                }
            }

            if (horizontalInput < 0)
            {
                spriteRenderer.flipX = isGravedadInvertida ? false : true;
            }
            else if (horizontalInput > 0)
            {
                spriteRenderer.flipX = isGravedadInvertida ? true : false;
            }
        }
        else
        {
            rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
            if (animator != null)
            {
                // Detener animaci√≥n de movimiento
                if (HasAnimatorParameter("running", AnimatorControllerParameterType.Bool))
                {
                    animator.SetBool("running", false);
                }
                else if (HasAnimatorParameter("isMoving", AnimatorControllerParameterType.Bool))
                {
                    animator.SetBool("isMoving", false);
                }
            }
        }

        rb.gravityScale = isGravedadInvertida ? -1 : 1;
    }

    private void Jump()
    {
        float jumpDirection = isGravedadInvertida ? -jumpForce : jumpForce;
        rb.linearVelocity = new Vector2(rb.linearVelocity.x, jumpDirection);
        Debug.Log($"üöÄ Salto ejecutado con fuerza: {jumpDirection}, Gravedad invertida: {isGravedadInvertida}");
    }

    private void Golpe()
    {
        // Evitar atacar si el jugador est√° muerto o muriendo
        if (currentHealth <= 0 || isDying || deathCoroutine != null)
        {
            Debug.Log("Golpe: jugador est√° muerto o muriendo, ignorando ataque");
            return;
        }
        
        if (isAttacking) return;
        
        isAttacking = true;
        
        // Activar animaci√≥n de ataque usando la l√≥gica simple como PlayerController2
        if (animator != null)
        {
            if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Trigger))
                animator.SetTrigger("isAttacking");
            else if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Bool))
                animator.SetBool("isAttacking", true);
        }
        
        Debug.Log("üó°Ô∏è Animaci√≥n de ataque activada");
        
        // Activar SwordAttack component si est√° asignado
        if (swordAttackComponent != null)
        {
            // Determinar direcci√≥n del ataque basado en la rotaci√≥n o flip del sprite
            if (spriteRenderer != null && spriteRenderer.flipX)
            {
                swordAttackComponent.AttackLeft();
                Debug.Log("üó°Ô∏è SwordAttack: Atacando hacia la izquierda");
            }
            else
            {
                swordAttackComponent.AttackRight();
                Debug.Log("üó°Ô∏è SwordAttack: Atacando hacia la derecha");
            }
        }
        else
        {
            Debug.LogWarning("‚ö†Ô∏è swordAttackComponent no est√° asignado en PlayerController");
        }
        
        // Detecci√≥n de enemigos en el radio de ataque (sistema adicional)
        if (controladorGolpe == null)
        {
            Debug.LogError("‚ùå controladorGolpe no est√° asignado en el PlayerController!");
            isAttacking = false;
            return;
        }
        
        Debug.Log($"üîç Iniciando detecci√≥n de enemigos desde {controladorGolpe.name} en posici√≥n {controladorGolpe.position} con radio {radioGolpe}");
        
        Collider2D[] objetos = Physics2D.OverlapCircleAll(controladorGolpe.position, radioGolpe);
        Debug.Log($"üîç Detectados {objetos.Length} objetos en el radio de ataque en posici√≥n {controladorGolpe.position} con radio {radioGolpe}");

        foreach (Collider2D colisionador in objetos)
        {
            Debug.Log($"üéØ Objeto detectado: {colisionador.name}, Tag: {colisionador.tag}");
            
            if (colisionador.CompareTag("Enemy"))
            {
                // Para enemigos comunes, usar el sistema de da√±o de DARK_GAME
                var enemigo = colisionador.transform.GetComponent<Enemigo>();
                if (enemigo != null)
                {
                    enemigo.TomarDa√±o(da√±oGolpe);
                    Debug.Log($"‚úÖ Da√±o aplicado a enemigo: {da√±oGolpe}");
                }
                
                // Para Slimes, usar su sistema de da√±o espec√≠fico
                var slime = colisionador.transform.GetComponent<Slime>();
                if (slime != null)
                {
                    Debug.Log($"üéØ Slime detectado: {colisionador.name}");
                    slime.TakeDamage(da√±oGolpe);
                    Debug.Log($"‚úÖ Da√±o aplicado a slime: {da√±oGolpe}");
                }
                else
                {
                    Debug.Log($"‚ö†Ô∏è Objeto con tag Enemy no tiene componente Slime: {colisionador.name}");
                }
            }
            else if (colisionador.CompareTag("Jefe"))
            {
                // Para jefes, usar el sistema espec√≠fico
                var mother = colisionador.transform.GetComponent<Mother>();
                if (mother != null)
                {
                    mother.TomarDa√±o(da√±oGolpe);
                    Debug.Log($"‚úÖ Da√±o aplicado a jefe: {da√±oGolpe}");
                }
            }
        }
        
        // Resetear el estado de ataque despu√©s de un tiempo
        StartCoroutine(ResetAttackCoroutine());
    }
    
    // M√©todo alternativo para compatibilidad con PlayerController2
    public void SwordAttack()
    {
        Golpe();
    }
    
    // M√©todos para Animation Events
    public void StartSwordAttack()
    {
        Debug.Log("üé¨ Animation Event: StartSwordAttack");
        if (swordAttackComponent != null)
        {
            // Determinar direcci√≥n del ataque basado en la rotaci√≥n o flip del sprite
            if (spriteRenderer != null && spriteRenderer.flipX)
            {
                swordAttackComponent.AttackLeft();
            }
            else
            {
                swordAttackComponent.AttackRight();
            }
        }
    }
    
    public void StopSwordAttack()
    {
        Debug.Log("üé¨ Animation Event: StopSwordAttack");
        if (swordAttackComponent != null)
        {
            swordAttackComponent.StopAttack();
        }
    }

    public void EndSwordAttack()
    {
        isAttacking = false;
        
        // Desactivar SwordAttack component si est√° asignado
        if (swordAttackComponent != null)
        {
            swordAttackComponent.StopAttack();
            Debug.Log("üó°Ô∏è SwordAttack: Ataque detenido");
        }
        
        // Solo resetear si es un Bool, los Triggers se resetean autom√°ticamente
        if (animator != null && HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Bool))
        {
            animator.SetBool("isAttacking", false);
        }
        Debug.Log("üó°Ô∏è Ataque finalizado");
    }

    private IEnumerator ResetAttackCoroutine()
    {
        yield return new WaitForSeconds(tiempoEntreAtaques);
        EndSwordAttack();
    }
    
    public void LockMovement()
    {
        canMove = false;
        rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
    }

    public void UnlockMovement()
    {
        canMove = true;
    }

    public void TakeDamage(int amount)
    {
        Debug.Log($"üí• TakeDamage llamado: amount={amount}, currentHealth={currentHealth}, isDying={isDying}");
        
        if (currentHealth <= 0 || isDying)
        {
            Debug.Log("‚ö†Ô∏è TakeDamage IGNORADO: jugador ya est√° muerto o muriendo");
            return;
        }

        currentHealth -= amount;
        currentHealth = Mathf.Max(currentHealth, 0); // Asegurar que no sea negativo
        cambioVida.Invoke(currentHealth);
        Debug.Log($"üíî Player: TakeDamage({amount}). Vida restante: {currentHealth}");

        if (currentHealth <= 0)
        {
            Debug.Log("üíÄ TakeDamage: Vida lleg√≥ a 0, llamando a Die()");
            Die();
        }
        else
        {
            // Reproducir animaci√≥n de da√±o/hit si existe el par√°metro
            if (animator != null)
            {
                if (HasAnimatorParameter("Hit", AnimatorControllerParameterType.Trigger))
                    animator.SetTrigger("Hit");
                if (HasAnimatorParameter("isHurt", AnimatorControllerParameterType.Trigger))
                    animator.SetTrigger("isHurt");
            }
            LockMovement();

            // Iniciar fallback para desbloquear movimiento
            if (hitCoroutine != null)
                StopCoroutine(hitCoroutine);
            hitCoroutine = StartCoroutine(HitReactionCoroutine());
        }
    }

    #region Sistema de Vida y Da√±o
    public void RecibirDa√±o(int da√±o)
    {
        Debug.Log($"üí• RecibirDa√±o llamado: da√±o={da√±o}, currentHealth={currentHealth}, isDying={isDying}");
        
        if (currentHealth <= 0 || isDying)
        {
            Debug.Log("‚ö†Ô∏è RecibirDa√±o IGNORADO: jugador ya est√° muerto o muriendo");
            return;
        }
        
        currentHealth -= da√±o;
        currentHealth = Mathf.Max(currentHealth, 0); // Asegurar que no sea negativo
        cambioVida.Invoke(currentHealth);
        
        Debug.Log($"üíî Da√±o recibido: {da√±o}. Vida restante: {currentHealth}");
        
        if (currentHealth <= 0)
        {
            Debug.Log("üíÄ RecibirDa√±o: Vida lleg√≥ a 0, llamando a Die()");
            Die();
        }
        else
        {
            // Activar animaci√≥n de golpe/da√±o
            if (animator != null && HasAnimatorParameter("Hit", AnimatorControllerParameterType.Trigger))
            {
                animator.SetTrigger("Hit");
            }
            
            // Detener corrutina anterior si existe
            if (hitCoroutine != null)
            {
                StopCoroutine(hitCoroutine);
            }
            hitCoroutine = StartCoroutine(HitReactionCoroutine());
        }
    }

    public void CurarVida(int cantidadCuracion)
    {
        currentHealth = Mathf.Min(currentHealth + cantidadCuracion, maxHealth);
        cambioVida.Invoke(currentHealth);
        Debug.Log($"Vida curada: +{cantidadCuracion}. Vida actual: {currentHealth}/{maxHealth}");
    }

    public bool PuedeCurarse()
    {
        return currentHealth < maxHealth;
    }

    private IEnumerator HitReactionCoroutine()
    {
        yield return new WaitForSeconds(hitDuration);
        UnlockMovement();
        hitCoroutine = null;
    }
    
    public void EndHurt()
    {
        // Llamado desde animaci√≥n al terminar el hit
        if (hitCoroutine != null)
        {
            StopCoroutine(hitCoroutine);
            hitCoroutine = null;
        }
        UnlockMovement();
    }

    public void Die()
    {
        Debug.Log($"üíÄ Die() llamado - isDying={isDying}, globalDeathInProgress={globalDeathInProgress}, deathCoroutine={deathCoroutine != null}, currentHealth={currentHealth}");
        
        // PROTECCI√ìN GLOBAL Y LOCAL: Evitar m√∫ltiples llamadas a Die()
        if (isDying || globalDeathInProgress)
        {
            Debug.Log("‚ö†Ô∏è Die() COMPLETAMENTE IGNORADO: muerte ya en progreso (local o global)");
            return;
        }
        
        // Marcar inmediatamente como muriendo GLOBALMENTE y LOCALMENTE
        isDying = true;
        globalDeathInProgress = true;
        currentHealth = 0; // Asegurar que la vida est√© en 0
        
        Debug.Log("üö© isDying y globalDeathInProgress establecidos a TRUE - bloqueando futuras llamadas a Die()");
        
        // Activar solo UNA animaci√≥n de muerte (priorizar "Death")
        if (animator != null)
        {
            if (HasAnimatorParameter("Death", AnimatorControllerParameterType.Trigger))
            {
                animator.SetTrigger("Death");
                Debug.Log("üé≠ Activando animaci√≥n: Death");
            }
            else if (HasAnimatorParameter("isDead", AnimatorControllerParameterType.Trigger))
            {
                animator.SetTrigger("isDead");
                Debug.Log("üé≠ Activando animaci√≥n: isDead");
            }
        }
        
        LockMovement();
        
        // Desactivar temporalmente el input de ataque
        if (attackAction != null)
        {
            attackAction.Disable();
            Debug.Log("üö´ Input de ataque desactivado durante la muerte");
        }
        
        // Detener todas las corrutinas activas para evitar conflictos
        if (deathCoroutine != null)
        {
            StopCoroutine(deathCoroutine);
            deathCoroutine = null;
        }
        if (hitCoroutine != null)
        {
            StopCoroutine(hitCoroutine);
            hitCoroutine = null;
        }
        
        // Iniciar proceso de muerte con fallback
        deathCoroutine = StartCoroutine(DeathCoroutine());
    }
    
    public void EndDeath()
    {
        // Llamado desde animaci√≥n de muerte
        if (deathCoroutine != null)
        {
            StopCoroutine(deathCoroutine);
            deathCoroutine = null;
        }
        PlayerDeath();
    }

    private IEnumerator DeathCoroutine()
    {
        Debug.Log("üíÄ Iniciando DeathCoroutine...");
        
        // Reducir el tiempo de espera para respawn m√°s r√°pido
        float waitTime = Mathf.Min(deathDuration, 3f); // M√°ximo 3 segundos
        Debug.Log($"üíÄ Esperando {waitTime} segundos antes del respawn...");
        yield return new WaitForSeconds(waitTime);
        
        Debug.Log("üíÄ DeathCoroutine completado, iniciando respawn...");
        deathCoroutine = null;
        PlayerDeath();
    }
    #endregion

    #region Sistema de Gravedad
    public void CambiarGravedad()
    {
        isGravedadInvertida = !isGravedadInvertida;
        
        Debug.Log($"=== CAMBIO DE GRAVEDAD ===");
        Debug.Log($"Gravedad invertida: {isGravedadInvertida}");
        
        if (isGravedadInvertida)
        {
            transform.rotation = Quaternion.Euler(0, 0, 180);
            rb.gravityScale = -1;
            Debug.Log("Aplicando gravedad invertida");
        }
        else
        {
            transform.rotation = Quaternion.Euler(0, 0, 0);
            rb.gravityScale = 1;
            Debug.Log("Aplicando gravedad normal");
        }
        
        // Resetear velocidad vertical para evitar efectos extra√±os
        rb.linearVelocity = new Vector2(rb.linearVelocity.x, 0);
    }

    public void RestaurarGravedad()
    {
        Debug.Log("=== RESTAURANDO GRAVEDAD ===");
        isGravedadInvertida = false;
        transform.rotation = Quaternion.Euler(0, 0, 0);
        rb.gravityScale = 1;
        rb.linearVelocity = new Vector2(rb.linearVelocity.x, 0);
        Debug.Log("Gravedad restaurada a estado normal");
    }
    #endregion

    #region Detecci√≥n de Colisiones y Triggers
    void OnTriggerEnter2D(Collider2D collision)
    {
        Debug.Log($"Trigger detectado con: {collision.gameObject.name}, Tag: {collision.gameObject.tag}");
        
        if (collision.gameObject.CompareTag("DeadZone"))
        {
            Debug.Log("Entrando en DeadZone - Respawning");
            PlayerDeath();
        }
        else if (collision.CompareTag("ZonaGravedad"))
        {
            Debug.Log("Entrando en ZonaGravedad - Cambiando gravedad");
            CambiarGravedad();
        }
        else if (collision.CompareTag("Enemy") && !isAttacking)
        {
            Debug.Log("Tocaste un enemigo - Recibiendo da√±o");
            RecibirDa√±o(1);
        }
        else if (collision.CompareTag("Diamante"))
        {
            Debug.Log("üíé ¬°Diamante recogido! Aumentando capacidad de cambio de gravedad +1");
            maxGravityChanges += 1;
            gravityChangesAvailable += 1;
            Destroy(collision.gameObject);
            ActualizarTextoGravedad();
        }
        else if (collision.name.ToLower().Contains("portal"))
        {
            Debug.Log("Portal detectado - Cambiando de nivel...");
            // Cambio de escena simplificado y m√°s seguro
            int currentScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().buildIndex;
            int nextScene = currentScene + 1;
            
            // Verificar si la pr√≥xima escena existe
            if (nextScene < UnityEngine.SceneManagement.SceneManager.sceneCountInBuildSettings)
            {
                UnityEngine.SceneManagement.SceneManager.LoadScene(nextScene);
            }
            else
            {
                Debug.LogWarning("No hay m√°s niveles disponibles");
            }
        }
        else
        {
            Debug.Log($"Tag no reconocido: {collision.gameObject.tag}");
        }
    }

    void OnCollisionEnter2D(Collision2D collision)
    {
        // No recibir da√±o si ya est√° muriendo/muerto
        if (isDying || currentHealth <= 0)
        {
            Debug.Log("OnCollisionEnter2D: Jugador muriendo/muerto, ignorando colisi√≥n de da√±o");
            return;
        }
        
        if (collision.gameObject.CompareTag("Enemy") && !isAttacking)
        {
            Debug.Log("Colisionaste con un enemigo - Recibiendo da√±o");
            RecibirDa√±o(1);
        }
    }
    #endregion

    #region Sistema de Respawn
    public void PlayerDeath()
    {
        Debug.Log("¬°Jugador ha muerto! Respawneando...");
        
        // Respawn de enemigos si est√° habilitado
        if (respawnEnemiesOnPlayerDeath)
        {
            EnemyManager.RespawnAll();
            SlimeManager.RespawnAll(); // Tambi√©n respawnear Slimes
            Debug.Log("EnemyManager: RespawnAll() called because player respawned.");
            Debug.Log("SlimeManager: RespawnAll() called because player respawned.");
        }
        else
        {
            EnemyManager.Clear();
            SlimeManager.Clear(); // Tambi√©n limpiar Slimes
            Debug.Log("EnemyManager: registry cleared (no respawn on player death).");
            Debug.Log("SlimeManager: registry cleared (no respawn on player death).");
        }
        
        rb.linearVelocity = Vector2.zero;
        
        // Encontrar punto de spawn
        GameObject spawn = GameObject.FindGameObjectWithTag("SpawnPoint");
        if (spawn != null)
        {
            transform.localPosition = spawn.transform.localPosition;
            transform.rotation = Quaternion.Euler(0, 0, 0);
            isGravedadInvertida = false;
            rb.gravityScale = 1;
            spriteRenderer.flipX = false;
            Debug.Log($"Jugador respawneado en: {spawn.transform.localPosition}");
        }
        else
        {
            Debug.LogError("No se encontr√≥ ning√∫n SpawnPoint con tag 'SpawnPoint'");
            transform.localPosition = Vector3.zero;
        }

        // Reiniciar contador de cambios de gravedad
        maxGravityChanges = baseMaxGravityChanges;
        gravityChangesAvailable = maxGravityChanges;
        ActualizarTextoGravedad();

        // Restaurar estado del Animator
        if (animator != null)
        {
            // Resetear todos los triggers
            animator.ResetTrigger("Death");
            animator.ResetTrigger("Hit");
            
            // Resetear par√°metros bool si existen
            if (HasAnimatorParameter("isMoving", AnimatorControllerParameterType.Bool))
                animator.SetBool("isMoving", false);
            if (HasAnimatorParameter("running", AnimatorControllerParameterType.Bool))
                animator.SetBool("running", false);
            if (HasAnimatorParameter("isJumping", AnimatorControllerParameterType.Bool))
                animator.SetBool("isJumping", false);
            if (HasAnimatorParameter("isFalling", AnimatorControllerParameterType.Bool))
                animator.SetBool("isFalling", false);
            // Solo resetear isAttacking si es Bool, los Triggers se resetean autom√°ticamente
            if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Bool))
                animator.SetBool("isAttacking", false);
            
            // Rebind y forzar estado idle
            animator.Rebind();
            animator.Update(0f);
            
            Debug.Log("üé≠ Animator reiniciado a estado idle");
        }

        // Reiniciar vida y estados
        currentHealth = maxHealth;
        cambioVida.Invoke(currentHealth);
        isAttacking = false;
        isDying = false; // Resetear el estado de muerte local
        globalDeathInProgress = false; // Resetear el estado de muerte global
        canMove = true; // Asegurar que el movimiento est√© desbloqueado
        
        Debug.Log($"‚úÖ PlayerDeath completado. Vida: {currentHealth}, canMove: {canMove}, isDying: {isDying}, globalDeathInProgress: {globalDeathInProgress}");
        
        // Limpiar corrutinas activas
        if (deathCoroutine != null)
        {
            StopCoroutine(deathCoroutine);
            deathCoroutine = null;
        }
        
        if (hitCoroutine != null)
        {
            StopCoroutine(hitCoroutine);
            hitCoroutine = null;
        }
        
        // Asegurar que el movimiento est√© completamente desbloqueado
        UnlockMovement();
        
        // Reactivar el input de ataque
        if (attackAction != null)
        {
            attackAction.Enable();
            Debug.Log("‚úÖ Input de ataque reactivado despu√©s del respawn");
        }
    }
    #endregion

    #region M√©todos Auxiliares
    private void ActualizarTextoGravedad()
    {
        if (txtGravedad != null)
        {
            txtGravedad.text = $"Total de saltos de gravedad: {gravityChangesAvailable}";
        }
    }

    private void VerificarAnimatorParametros()
    {
        if (animator != null)
        {
            Debug.Log("=== VERIFICANDO PAR√ÅMETROS DEL ANIMATOR ===");
            
            bool hasMovementParam = false;
            
            if (HasAnimatorParameter("isMoving", AnimatorControllerParameterType.Bool))
            {
                Debug.Log("‚úÖ Par√°metro Bool 'isMoving' encontrado");
                hasMovementParam = true;
            }
            
            if (HasAnimatorParameter("running", AnimatorControllerParameterType.Bool))
            {
                Debug.Log("‚úÖ Par√°metro Bool 'running' encontrado");
                hasMovementParam = true;
            }
            
            if (HasAnimatorParameter("isJumping", AnimatorControllerParameterType.Bool))
            {
                Debug.Log("‚úÖ Par√°metro Bool 'isJumping' encontrado");
            }
            else
            {
                Debug.LogWarning("‚ùå Par√°metro Bool 'isJumping' NO encontrado");
            }
            
            if (HasAnimatorParameter("isFalling", AnimatorControllerParameterType.Bool))
            {
                Debug.Log("‚úÖ Par√°metro Bool 'isFalling' encontrado");
            }
            else
            {
                Debug.LogWarning("‚ùå Par√°metro Bool 'isFalling' NO encontrado");
            }
            
            if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Bool))
            {
                Debug.Log("‚úÖ Par√°metro Bool 'isAttacking' encontrado");
            }
            else if (HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Trigger))
            {
                Debug.Log("‚úÖ Par√°metro Trigger 'isAttacking' encontrado (esto es correcto)");
            }
            else
            {
                Debug.LogWarning("‚ùå Par√°metro 'isAttacking' NO encontrado");
            }
            
            if (HasAnimatorParameter("Hit", AnimatorControllerParameterType.Trigger))
            {
                Debug.Log("‚úÖ Trigger 'Hit' encontrado");
            }
            else
            {
                Debug.LogWarning("‚ùå Trigger 'Hit' NO encontrado");
            }
            
            if (HasAnimatorParameter("Death", AnimatorControllerParameterType.Trigger))
            {
                Debug.Log("‚úÖ Trigger 'Death' encontrado");
            }
            else
            {
                Debug.LogWarning("‚ùå Trigger 'Death' NO encontrado");
            }
            
            if (!hasMovementParam)
            {
                Debug.LogWarning("‚ùå Ning√∫n par√°metro de movimiento encontrado. Las animaciones de caminar no funcionar√°n.");
            }
            
            Debug.Log("=== FIN VERIFICACI√ìN PAR√ÅMETROS ===");
        }
        else
        {
            Debug.LogError("‚ùå No se encontr√≥ componente Animator en el GameObject");
        }
    }

    private bool HasAnimatorParameter(string name, UnityEngine.AnimatorControllerParameterType type)
    {
        if (animator == null) return false;
        foreach (var p in animator.parameters)
        {
            if (p.name == name && p.type == type) return true;
        }
        return false;
    }

    public void Destroy()
    {
        Destroy(gameObject);
    }
    
    private void OnDestroy()
    {
        if (testGravityAction != null)
        {
            testGravityAction.Disable();
            testGravityAction.Dispose();
        }
        
        if (moveAction != null)
        {
            moveAction.Disable();
            moveAction.Dispose();
        }
        
        if (attackAction != null)
        {
            attackAction.Disable();
            attackAction.Dispose();
        }
        
        if (jumpAction != null)
        {
            jumpAction.Disable();
            jumpAction.Dispose();
        }
    }

    private void OnDrawGizmos()
    {
        // Gizmo para el detector de suelo
        if (detector != null)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(detector.position, sizeDetector);
        }
        
        // Gizmo para el √°rea de ataque
        if (controladorGolpe != null)
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(controladorGolpe.position, radioGolpe);
        }
    }
    
    // M√©todo para depuraci√≥n - mostrar estado actual de animaciones
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public void MostrarEstadoAnimaciones()
    {
        if (animator == null) 
        {
            Debug.Log("‚ùå Animator es null");
            return;
        }
        
        Debug.Log("üé≠ === ESTADO ACTUAL DE ANIMACIONES ===");
        Debug.Log($"üèÉ running: {(HasAnimatorParameter("running", AnimatorControllerParameterType.Bool) ? animator.GetBool("running") : "N/A")}");
        Debug.Log($"‚¨ÜÔ∏è isJumping: {(HasAnimatorParameter("isJumping", AnimatorControllerParameterType.Bool) ? animator.GetBool("isJumping") : "N/A")}");
        Debug.Log($"‚¨áÔ∏è isFalling: {(HasAnimatorParameter("isFalling", AnimatorControllerParameterType.Bool) ? animator.GetBool("isFalling") : "N/A")}");
        Debug.Log($"‚öîÔ∏è isAttacking: {(HasAnimatorParameter("isAttacking", AnimatorControllerParameterType.Bool) ? animator.GetBool("isAttacking") : "N/A")}");
        Debug.Log($"üåç En suelo (isGrounded): {isGrounded}");
        Debug.Log($"üí® Velocidad Y: {rb.linearVelocity.y:F2}");
        Debug.Log($"ü§ñ Puede moverse: {canMove}");
        Debug.Log($"‚ù§Ô∏è Vida: {currentHealth}/{maxHealth}");
        Debug.Log($"üîÑ Gravedad invertida: {isGravedadInvertida}");
        Debug.Log($"‚öîÔ∏è Est√° atacando: {isAttacking}");
        Debug.Log("============================================");
    }
    #endregion
}